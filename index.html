<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" href="data:,">
		<title>Foreign Language Alphabet Study Help (FLASH) Cards</title>
	</head>

	<body>
		<center>
			<h1>Foreign Language Alphabet Study Help (FLASH) Cards</h1>
			<div>
				<p>Instructions: Please type the sound of the letter followed by a [space] or [enter].</p>
				<p id="front" style="scale: 2; margin: 2em;"></p>
				<input type="text" id="input"></input>
				<p id="hint" style="height: 1em;"></p>
				<p id="history"></p>
			</div>
		</center>
	</body>

	<script>

		let input_ele;
		let front_ele;
		let hint_ele;
		let history_ele;

		let data;
		let current_card;
		let display_hint;
		let answer_count;
		let history;

		function start() {

					input_ele = document.getElementById('input');
					front_ele = document.getElementById('front');
					hint_ele = document.getElementById('hint');
					history_ele = document.getElementById('history');

					data = JSON.parse(window.localStorage.getItem('data'));
					//if (data == null) {
					{
								data = init_data();
								window.localStorage.setItem('data', JSON.stringify(data));					
							}
					if (data.version !== 1) {
								throw "unsupported data version: " + data.version;
							}
					display_hint = false;
					answer_count = 0;
					history = [];

					input_ele.addEventListener('keyup', keyup);
					input_ele.focus();

					pick_next_card();
					render();
				}

		function pick_next_card() {
					let last_card = current_card;
					let cards = Object.values(data.decks[0].cards);

					let min_learning = Number.MAX_SAFE_INTEGER;
					let learning = [];
					let learned = [];

					for (let card of cards) {
								let answers = data.decks[data.current_deck_idx].answers[card.front] || [];
								if (answers.length < data.settings.learn_size) {
											learning.push(card);
											min_learning = Math.min(min_learning, card.group);
										}
								else {
											learned.push(card);
										}
							}
					learning = learning.filter(x => x.group === min_learning);

					let r = Math.random();
					if (learning.length !== 0 && (learned.length === 0 || r < data.settings.learn_draw_rate)) {
								current_card = learning[Math.floor(Math.random() * learning.length)]; //TODO weighted
								display_hint = true;
							}
					else {
								current_card = learned[Math.floor(Math.random() * learned.length)]; //TODO weighted
								display_hint = false;
							}

					answer_count = 0;

					if (current_card == last_card) {
								// avoid confusing the user by always using a different card
								pick_next_card(); //HACK
							}
				}

		function submit_answer(answer) {
					let answers = data.decks[data.current_deck_idx].answers;
					let answer_history = answers[current_card.front] || [];
					answers[current_card.front] = answer_history;

					if (current_card.back === answer) {
								let correct = answer_count === 0;
								answer_history.push(correct);
								while (answer_history.length > data.settings.answer_history_size) {
											answer_history.shift();
										}
								let up = answer_history.filter(x => x).length;
								let down = answer_history.length - up;
								let value = Math.ceil(score(up, down) * 100) / 100.0;

								if (correct) {
											answer_history.push(true);
											history.push('<span style="color:MediumSeaGreen;">✓</span> +1 for correct answer to ' + current_card.front + ' ( ' + value + ' )');
										}
								else {
											answer_history.push(false);
											history.push('<span style="color:LightCoral;">✗</span> -1 for incorrect answer to ' + current_card.front + ' ( ' + value + ') ');
										}
							}
					else {
								answer_count++;
								display_hint = true;
								return;
							}


					if (history.length > data.settings.history_size) {
								history.shift();
							}
					pick_next_card();
				}

		function keyup(e) {
					if (e.code === 'Space' || e.code === 'Enter') {
								let answer = input_ele.value.trim();
								if (answer === '')
									return;
								submit_answer(answer);
								input_ele.value = '';
							}
					render();
				}

		function render() {
					front_ele.textContent = current_card.front;
					hint_ele.textContent = display_hint ? 'Hint: ' + (current_card.hint || current_card.back) : ' ';
					let s = '';
					for (h of history) {
								s += '<br>' + h;
							}
					history_ele.innerHTML = s.trim();
					if (answer_count > 0) {
								input_ele.style.backgroundColor = 'LightCoral';
							}
					else {
								input_ele.style.backgroundColor = null;
							}
				}

		function init_data() {
					let data = {
								version: 1,
								decks: [],
								current_deck_idx: null,
								settings: {
											answer_history_size: 100, // number of user answers to remember
											history_size: 5, // number of user answers to remember
											learn_size: 3, // number of times to present the card with a hint before considering it "learned" and moving on to other card(s)
											learn_draw_rate: 0.75, // probably of choosing a card being learned
											draw_weight_modifier: 1.0 // near 0 results in uniform draws from learned. Higher values will focus on cards with poor score.
										}
							};

					data.decks.push(create_jp_deck());
					data.current_deck_idx = 0;

					return data;
				}

		// lower of wilson interval
		function score(positive, negative) {
					if (positive === 0 && negative === 0) return 0;
					let p = positive;
					let n = negative;
					return ((p + 1.9208) / (p + n) - 1.96 * Math.sqrt((p * n) / (p + n) + 0.9604) / (p + n)) / (1 + 3.8416 / (p + n))
				}

		function create_jp_deck() {
					let cards = {};

					let hiragana_table = `
	 _	a	i	u	e	o	n
	 _	あ	い	う	え	お	ん
	 k	か	き	く	け	こ
	 g	が	ぎ	ぐ	げ	ご
	 s	さ	し	す	せ	そ
	 z	ざ	じ	ず	ぜ	ぞ
	 t	た	ち	つ	て	と
	 d	だ	ぢ	づ	で	ど
	 n	な	に	ぬ	ね	の
	 h	は	ひ	ふ	へ	ほ
	 b	ば	び	ぶ	べ	ぼ
	 p	ぱ	ぴ	ぷ	ぺ	ぽ
	 m	ま	み	む	め	も
	 y	や		ゆ		よ
	 r	ら	り	る	れ	ろ
	 w	わ				を
	 `;
					hiragana_table = hiragana_table.trim().split('\n').map(row => row.trim().split('\t'));

					for (let row = 1; row < hiragana_table.length; ++row) {
								for (let column = 1; column < hiragana_table[row].length; ++column) {
											let card = {
														front: hiragana_table[row][column],
														back: hiragana_table[row][0] + hiragana_table[0][column],
														group: row - 1
													};
											card.back = card.back.replaceAll('_', '');
											if (card.front !== '') {
														cards[card.front] = card;
													}
										}
							}

					let exceptional_hiragana = [
								{
											front: "ふ",
											back: "fu"
										},
								{
											front: "し",
											back: "shi"
										},
								{
											front: "じ",
											back: "ji"
										},
								{
											front: "ち",
											back: "chi"
										},
								{
											front: "つ",
											back: "tsu" //TODO support alternative "tu" typing?
										},
								{
											front: "ぢ",
											back: "di",
											hint: "di (uncommon, sounds like ji / じ in most dialects)"
										},
								{
											front: "づ",
											back: "du",
											hint: "du (uncommon, sounds like zu / ず in most dialects)"
										}
							];

					for (let item of exceptional_hiragana) {
								let card = cards[item.front];
								card.back = item.back;
								card.hint = item.hint;
							}


					let hiragana_digraphs = []; //TODO

					let katakana_table = `
	 a	i	u	e	o	n
	 ∅	ア	イ	ウ	エ	オ	ン
	 k	カ	キ	ク	ケ	コ
	 g	ガ	ギ	グ	ゲ	ゴ
	 s	サ	シ	ス	セ	ソ
	 z	ザ	ジ	ズ	ゼ	ゾ
	 t	タ	チ	ツ	テ	ト
	 d	ダ	ヂ	ヅ	デ	ド
	 n	ナ	ニ	ヌ	ネ	ノ
	 h	ハ	ヒ	フ	ヘ	ホ
	 b	バ	ビ	ブ	ベ	ボ
	 p	パ	ピ	プ	ペ	ポ
	 m	マ	ミ	ム	メ	モ
	 y	ヤ		ユ		ヨ
	 r	ラ	リ	ル	レ	ロ
	 w	ワ				ヲ
	 `;

					//TODO


					return {
								name: 'jp -> en',
								cards: cards,
								answers: {}
							};
				}

		start();
	</script>

</html>

